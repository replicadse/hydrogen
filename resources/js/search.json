[[{"l":"hydrogen","p":["hydrogen is a kubernetes native API gateway for websocket connections that indirects messages into HTTP requests."]},{"i":"release-schemes--cycles","l":"Release schemes & cycles","p":["As hydrogen now gets more complete in it's feature set, there are final preparations to be made before releasing a v1.","There will be 1.0.0-alpha.x releases first with the first coming up end of June 2022. These are meant to be for testing purposes only and will primarily serve for identifying which things are still missing that have not come up yet. Following the alpha releases, there will be a beta phase. The feature set for v1.0 will be complete upon entering the beta phase and there will only be fixes made to the existing features. At this point in time, the documentation about the software will also be much more in depth and detailed although it might not be 100% complete. Following the beta phase with release candidates, v1.0 will be published. Following the v1.0 release, hydrogen will strictly adhere to the semver v2 versioning scheme."]},{"l":"Roadmap to v1","p":["All work, features and generally everything that will be included in / done before the v1.0 release will be bundled in this milestone."]},{"i":"v10-features","l":"v1.0 features","p":["Gateway & Message processor deployment via CRDs & custom resources Gateways and message processors are not deployed from the HELM chart but can be deployed by creating the respective custom resources which will then be synced by the operator that is running in the namespace. This allows ingress/egress route definition similar to other gateways, n-k relations between gateways and message processors (eg. many gateways (routes) -> single processor). Changes to the spec of the CRs will result in the components related to this resource being recreated.","Bidirectional communication (client <--> server) Client messages are sent from the client, server messages are sent towards any running instance of hydrogen and forwarded towards the client from the instance that holds it's connection. Avoiding persistent connections towards your service is crucial to reach a near zero downtime when deploying and an increased consumer satisfaction.","Broadcasting Broadcast messages to all connections that are connected to instances of one group. This can be interesting for periodic updates, ticks or similar use-cases with connections that act as subscriptions to updates.","Flexible routing You can choose from letting the mproc application run in regex or in dss mode. Regex mode will evaluate the messages based on a regular expression and, if it matches, forward the message to the corresponding service. DSS mode will invoke a separate rules engine service that determines and returns the destination for the message which the server then invokes.","Built-in authorizer It brings built in authorization that is performed before a persistent connection is established.","OnConnect/OnDisconnect services These are invoked when a client has connected / disconnected respectively.","Monitoring Structured log messages for events and, if configured, interval reporting about the application's state are available.","Easy installs via HELM charts It's easy to install the application - just do a helm install with the appropriate chart values and you're ready to go.","Multi language / framework support By deciding against a DSL or other language/framework lock-ins for routing etc., you can implement authorization, connect, message routing, message handling and disconnect in your own favorite language. The only implementations required are the routing service and at least one destination for messages it points to. In regex mode, the mproc will use regular expressions to determine the message destination.","Message persistence and retries Messages are sent to a NATS/Jetstream stream which will buffer messages and only release if they are acknowledged. This abstraction into an async architecture will guarantee an at-least-once delivery for client->server messages.","Connection contexts The authorizer can return a context object for the connection if it authorizes it. This context will be included in every client to server message and be available for the downstream services to use.","Forced disconnects Sending a disconnect request via the respective route to any gateway will lead to the specified connection being forced to disconnect with the given reason. Useful if you want to enforce a new authorization."]},{"l":"v1 Architecture abstract"}],[{"l":"Configuration"},{"l":"Example configuration"},{"l":"Schema","p":["$host:$port string","0.0.0.0:8080","0x0001","1.0.0","262144(=256* 1024)","30","60","All the different routes to which a client can connect.","An identifier for grouping multiple instances.","Array of string","bidi or uni_server_to_client","Communication mode of the server.","Description","empty object","Example","group_id","Headers to send to the authorizer on invocation.","Headers to send to the connect dss on invocation.","Headers to send to the disconnect dss on invocation.","http://hydrogen-dss-authorizer:8080","http://hydrogen-dss-connect:8080","http://hydrogen-dss-disconnect:8080","hydrogen","Information about the message stream to use (NATS/JetStream).","Key","Makes server support bidirectional messages.","Map<String, String>","Marks server as server to client messages only.","nats://hydrogen-nats:4222","no","object","redis","redis://hydrogen-redis-master:6379","redis.endpoint","Required","routes","routes.authorizer","routes.authorizer.endpoint","routes.authorizer.headers","routes.connect","routes.connect.endpoint","routes.connect.headers","routes.disconnect","routes.disconnect.endpoint","routes.disconnect.headers","routes.endpoints","semver v2 compatible string","server","server.address","server.comms","server.comms.bidi","server.comms.bidi.stream","server.comms.bidi.stream.endpoint","server.comms.bidi.stream.name","server.comms.uni_server_to_client","server.connection_timeout_sec","server.heartbeat_interval_sec","server.max_out_message_size","server.stats_interval_sec","string","The address to which the server binds.","The authorizer downstream service.","The authorizer endpoint.","The connect downstream service.","The connect endpoint.","The disconnect downstream service.","The disconnect endpoint.","The downstream service routes.","The duration (in seconds) between heartbeats the client has to answer. This must be less than the timeout duration server.connection_timeout_sec.","The duration (in seconds) when a connection times out after missing heartbeats.","The endpoint on which to connect to NATS.","The endpoint on which to connect to redis.","The maximum message size in bytes the server will accept from the client.","The redis configuration.","The seconds in between stats reporting. No stats are reported if key is missing.","The server configuration.","The stream name that will be used for client message brokering.","The version of this config.","Type","u16","u64","URL string","version","yes"]}],[{"l":"Downstream services","p":["hydrogen will invoke a multitude of downstream services to process messages. Most of these are optional."]},{"i":"authorizer-optional","l":"Authorizer (optional)"},{"l":"Request"},{"l":"Response","p":["HTTP code 200 for success, other codes will make the connection abort due to an authorization error (401)."]},{"i":"connect-optional","l":"Connect (optional)"},{"i":"request-1","l":"Request"},{"i":"response-1","l":"Response","p":["HTTP code 200 for success, other codes will make the connection abort due to an internal error."]},{"i":"disconnect-optional","l":"Disconnect (optional)"},{"i":"request-2","l":"Request"},{"i":"response-2","l":"Response"}],[{"l":"Endpoints"},{"i":"ws--ws","l":"`WS @ /ws/","p":["This is the primary socket endpoint clients need connect to. Endpoints are specified in the config file. It will trigger the connection pipeline before and during connect and trigger a disconnect event on client disconnect. Messages are sent through the open connections to this endpoint both from client to server and vice versa. When connecting, every established connection gets a unique connection_id assigned that is also transported to every downstream service which is invoked at any point (since the connection was not permitted yet at that point in time). Keep in mind that this id is given per connection and one client could have more than one connection open."]},{"i":"httpget--health","l":"HTTP/GET @ /health","p":["A basic health check endpoint. Will return code 200 and a static JSON formatted response body."]},{"i":"httppost--connectionsconnection_id_send","l":"HTTP/POST @ /connections/$connection_id/_send","p":["This endpoint is used in order to have a message sent from the backend to a connected client. The request body will be transmitted as text."]},{"i":"httppost--connectionsconnection_id_disconnect","l":"HTTP/POST @ /connections/$connection_id/_disconnect","p":["Forces a disconnect for the given connection."]},{"i":"httppost--connections_broadcast","l":"HTTP/POST @ /connections/_broadcast","p":["Broadcasts a message to all connections. Optional query params are endpoints[]=, can be set multiple times. If specified, only connections to the specified endpoints will receive the broadcast message. Example: $BASE_URL/connections/_broadcast?endpoints%5B%5D=%2Ftestendpoints%5B%5D=%2F will send broadcast to endpoint / and /test."]}],[{"l":"Configuration"},{"l":"Example configuration"},{"l":"Schema","p":["\"^!\" for every message starting with \"!\" or \".*\" for catching all","0x0001","0x01","1.0.0","An identifier for grouping multiple instances.","array","Contains the regular expressions and the routes to which they lead if they match. The expressions will be checked sequentially. If none match, the message is logged and dropped. A catch-all rule at the end is usually a good idea.","Description","Downstream service mode - invokes a remote rules engine which returns the message destination (for more complex use-cases).","engine_mode","engine_mode.dss","engine_mode.dss.rules_engine","engine_mode.dss.rules_engine.endpoint","engine_mode.dss.rules_engine.headers","engine_mode.regex","engine_mode.regex.rules","engine_mode.regex.rules.$.regex","engine_mode.regex.rules.$.route","engine_mode.regex.rules.$.route.endpoint","engine_mode.regex.rules.$.route.headers","Example","group_id","Headers to send to the message destination on invocation.","Headers to send to the rules engine dss on invocation.","http://hydrogen-dss-sink-a:8080","http://hydrogen-sink-a:8080","hydrogen","Key","Map<String, String>","nats://hydrogen-nats:4222","no","object","object (enum) - needs one mode active","Regex mode - forwarding messages by evaluating them over regular expressions.","regex string","Required","semver v2 compatible string","stream","stream.consumer_name","stream.endpoint","stream.name","string","The config for consuming messages on a stream.","The durable name of the consumer on the stream (see NATS documentation for more information).","The endpoint on which to connect to NATS.","The engine mode details which are used to process messages.","The HTTP endpoint to the message destination.","The regular that has to match expression for this destination.","The route to the message destination.","The rules engine downstream service.","The rules engine endpoint.","The stream name that will be used for client message brokering.","The version of this config.","Type","URL string","version","yes"]}],[{"l":"Downstream services","p":["hydrogen will invoke a multitude of downstream services to process messages. Most of these are optional."]},{"i":"rules-engine-required-if-in-dss-mode","l":"Rules engine (required if in DSS mode)"},{"l":"Request"},{"l":"Response","p":["HTTP code 200 for success, other codes will make the message not being consumed."]},{"i":"message-destination-given-by-rules-engine","l":"Message destination (given by rules engine)"},{"i":"request-1","l":"Request"},{"i":"response-1","l":"Response","p":["HTTP code 200 for success, other codes will make the message not being consumed."]}],[{"l":"Architecture","p":["The following diagram shows an example message flow if the mproc runs in DSS mode."]}]]