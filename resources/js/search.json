[[{"l":"spoderman","p":["spoderman is a kubernetes native API gateway for websocket connections that indirects messages into HTTP requests."]},{"i":"release-schemes--cycles","l":"Release schemes & cycles","p":["As spoderman now gets more complete in it's feature set, there are final preparations to be made before releasing a v1.","There will be 1.0.0-alpha.x releases first with the first coming up end of June 2022. These are meant to be for testing purposes only and will primarily serve for identifying which things are still missing that have not come up yet. Following the alpha releases, there will be a beta phase. The feature set for v1.0 will be complete upon entering the beta phase and there will only be fixes made to the existing features. At this point in time, the documentation about the software will also be much more in depth and detailed although it might not be 100% complete. Following the beta phase with release candidates, v1.0 will be published. Following the v1.0 release, spoderman will strictly adhere to the semver v3 versioning scheme."]},{"l":"Roadmap to v1","p":["All work, features and generally everything that will be included in / done before the v1.0 release will be bundled in this milestone."]},{"i":"v10-features","l":"v1.0 features","p":["Bidirectional communication (client <--> server) Client messages are sent from the client, server messages are sent towards any running instance of spoderman and forwarded towards the client from the instance that holds it's connection. Avoiding persistent connections towards your service is crucial to reach a near zero downtime when deploying and an increased consumer satisfaction.","Routing service No fancy DSL or other technique required. For every request, a routing service is invoked which returns the destination for that message including other metadata (like headers).","Authorization service It brings built in authorization that is performed before a persistent connection is established.","OnConnect/OnDisconnect services These are invoked when a client has connected / disconnected respectively.","Monitoring Structured log messages for events and, if configured, interval reporting about the application's state are available.","Easy installs via HELM charts It's easy to install the application - just do a helm install with the appropriate chart values and you're ready to go.","Multi language / framework support By deciding against a DSL or other language/framework lock-ins for routing etc., you can implement authorization, connect, message routing, message handling and disconnect in your own favorite language. The only implementations required are the routing service and at least one destination for messages it points to.","Message persistence and retries Messages are sent to a NATS/Jetstream stream which will buffer messages and only release if they are acknowledged. This will guarantee a at-least-once delivery for client->server messages.","Connection contexts The authorizer can return a context object for the connection if it authorizes it. This context will be included in every client to server message and be available for the downstream services to use."]}],[{"l":"Configuration"},{"l":"Example configuration"},{"l":"Schema","p":["$host:$port string","0.0.0.0:8080","1.0.0","262144(=256* 1024)","30","60","client","Description","Example","Headers to send to the authorizer on invocation.","Headers to send to the connect dss on invocation.","Headers to send to the disconnect dss on invocation.","http://spoderman-dss-authorizer:8080","http://spoderman-dss-connect:8080","http://spoderman-dss-disconnect:8080","Key","Map<String, String>","nats","nats://spoderman-nats:4222","nats.endpoint","nats.stream","no","object","redis","redis://spoderman-redis-master:6379","redis.endpoint","Required","routes","routes.authorizer","routes.authorizer.endpoint","routes.authorizer.headers","routes.connect","routes.connect.endpoint","routes.connect.headers","routes.disconnect","routes.disconnect.endpoint","routes.disconnect.headers","semver v3 compatible string","server","server.address","server.connection_timeout_sec","server.heartbeat_interval_sec","server.max_out_message_size","server.stats_interval_sec","string","The address to which the server binds.","The authorizer downstream service.","The authorizer endpoint.","The connect downstream service.","The connect endpoint.","The disconnect downstream service.","The disconnect endpoint.","The downstream service routes.","The duration (in seconds) between heartbeats the client has to answer. This must be less than the timeout duration server.connection_timeout_sec.","The duration (in seconds) when a connection times out after missing heartbeats.","The endpoint on which to connect to NATS.","The endpoint on which to connect to redis.","The maximum message size in bytes the server will accept from the client.","The NATS configuration.","The redis configuration.","The seconds in between stats reporting. No stats are reported if key is missing.","The server configuration.","The stream name that will be used for client message brokering.","The version of this config.","Type","u16","u64","URL string","version","yes"]}],[{"l":"Downstream services","p":["spoderman will invoke a multitude of downstream services to process messages. Most of these are optional."]},{"i":"authorizer-optional","l":"Authorizer (optional)"},{"l":"Request"},{"l":"Response","p":["HTTP code 200 for success, other codes will make the connection abort due to an authorization error (401)."]},{"i":"connect-optional","l":"Connect (optional)"},{"i":"request-1","l":"Request"},{"i":"response-1","l":"Response","p":["HTTP code 200 for success, other codes will make the connection abort due to an internal error."]},{"i":"disconnect-optional","l":"Disconnect (optional)"},{"i":"request-2","l":"Request"},{"i":"response-2","l":"Response"}],[{"l":"Endpoints"},{"i":"wss--ws","l":"WSS @ /ws","p":["This is the primary socket endpoint clients need connect to. It will trigger the connection pipeline before and during connect and trigger a disconnect event on client disconnect. Messages are sent through the open connections to this endpoint both from client to server and vice versa. When connecting, every established connection gets a unique connection_id assigned that is also transported to every downstream service which is invoked at any point (since the connection was not permitted yet at that point in time). Keep in mind that this id is given per connection and one client could have more than one connection open."]},{"i":"httpget--health","l":"HTTP/GET @ /health","p":["A basic health check endpoint. Will return code 200 and a static JSON formatted response body."]},{"i":"httppost--connectionsconnection_id_send","l":"HTTP/POST @ /connections/$connection_id/_send","p":["This endpoint is used in order to have a message sent from the backend to a connected client. The request body will be transmitted as text."]},{"i":"httppost--connectionsconnection_id_disconnect","l":"HTTP/POST @ /connections/$connection_id/_disconnect","p":["Forces a disconnect for the given connection."]}],[{"l":"Configuration"},{"l":"Example configuration"},{"l":"Schema","p":["1.0.0","client","Description","Example","Headers to send to the rules engine dss on invocation.","http://spoderman-dss-disconnect:8080","Key","Map<String, String>","nats://spoderman-nats:4222","no","object","queue","queue.nats","queue.nats.endpoint","queue.nats.stream","Required","routes","routes.rules_engine","routes.rules_engine.endpoint","routes.rules_engine.headers","semver v3 compatible string","string","The config for consuming messages.","The downstream service routes.","The endpoint on which to connect to NATS.","The NATS configuration.","The rules engine downstream service.","The rules engine endpoint.","The stream name that will be used for client message brokering.","The version of this config.","Type","URL string","version","yes"]}],[{"l":"Downstream services","p":["spoderman will invoke a multitude of downstream services to process messages. Most of these are optional."]},{"i":"rules-engine-required","l":"Rules engine (required)"},{"l":"Request"},{"l":"Response","p":["HTTP code 200 for success, other codes will make the message not being consumed."]},{"i":"message-destination-given-by-rules-engine","l":"Message destination (given by rules engine)"},{"i":"request-1","l":"Request"},{"i":"response-1","l":"Response","p":["HTTP code 200 for success, other codes will make the message not being consumed."]}],[{"l":"Architecture"}]]